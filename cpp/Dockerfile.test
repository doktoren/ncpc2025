# Multi-stage Dockerfile for C++ algorithms with optimal caching
# Each algorithm is a separate build stage that only rebuilds when its file changes

FROM gcc:13.2.0 AS toolchain
WORKDIR /workspace

# Create test script
RUN echo '#!/bin/bash\n\
set -e\n\
ALGORITHM=$1\n\
mkdir -p /out\n\
g++ -x c++ -g -O2 -std=gnu++20 -static ${ALGORITHM}.cpp -o /out/${ALGORITHM}\n\
/out/${ALGORITHM}\n\
echo "${ALGORITHM}" > /out/${ALGORITHM}.success' > /test.sh && chmod +x /test.sh

# Individual algorithm stages
FROM toolchain AS bellman_ford
COPY bellman_ford.cpp ./
RUN /test.sh bellman_ford

FROM toolchain AS bipartite_match
COPY bipartite_match.cpp ./
RUN /test.sh bipartite_match

FROM toolchain AS convex_hull
COPY convex_hull.cpp ./
RUN /test.sh convex_hull

FROM toolchain AS dijkstra
COPY dijkstra.cpp ./
RUN /test.sh dijkstra

FROM toolchain AS edmonds_karp
COPY edmonds_karp.cpp ./
RUN /test.sh edmonds_karp

FROM toolchain AS fenwick_tree
COPY fenwick_tree.cpp ./
RUN /test.sh fenwick_tree

FROM toolchain AS kmp
COPY kmp.cpp ./
RUN /test.sh kmp

FROM toolchain AS kosaraju_scc
COPY kosaraju_scc.cpp ./
RUN /test.sh kosaraju_scc

FROM toolchain AS lca
COPY lca.cpp ./
RUN /test.sh lca

FROM toolchain AS polygon_area
COPY polygon_area.cpp ./
RUN /test.sh polygon_area

FROM toolchain AS prefix_tree
COPY prefix_tree.cpp ./
RUN /test.sh prefix_tree

FROM toolchain AS priority_queue
COPY priority_queue.cpp ./
RUN /test.sh priority_queue

FROM toolchain AS segment_tree
COPY segment_tree.cpp ./
RUN /test.sh segment_tree

FROM toolchain AS skiplist
COPY skiplist.cpp ./
RUN /test.sh skiplist

FROM toolchain AS sprague_grundy
COPY sprague_grundy.cpp ./
RUN /test.sh sprague_grundy

FROM toolchain AS suffix_array
COPY suffix_array.cpp ./
RUN /test.sh suffix_array

FROM toolchain AS topological_sort
COPY topological_sort.cpp ./
RUN /test.sh topological_sort

FROM toolchain AS two_sat
COPY two_sat.cpp ./
RUN /test.sh two_sat

FROM toolchain AS union_find
COPY union_find.cpp ./
RUN /test.sh union_find

# Final stage that aggregates all results
FROM toolchain AS all
RUN --mount=from=bellman_ford,src=/out/bellman_ford.success,target=/mnt/bellman_ford.success \
    --mount=from=bipartite_match,src=/out/bipartite_match.success,target=/mnt/bipartite_match.success \
    --mount=from=convex_hull,src=/out/convex_hull.success,target=/mnt/convex_hull.success \
    --mount=from=dijkstra,src=/out/dijkstra.success,target=/mnt/dijkstra.success \
    --mount=from=edmonds_karp,src=/out/edmonds_karp.success,target=/mnt/edmonds_karp.success \
    --mount=from=fenwick_tree,src=/out/fenwick_tree.success,target=/mnt/fenwick_tree.success \
    --mount=from=kmp,src=/out/kmp.success,target=/mnt/kmp.success \
    --mount=from=kosaraju_scc,src=/out/kosaraju_scc.success,target=/mnt/kosaraju_scc.success \
    --mount=from=lca,src=/out/lca.success,target=/mnt/lca.success \
    --mount=from=polygon_area,src=/out/polygon_area.success,target=/mnt/polygon_area.success \
    --mount=from=prefix_tree,src=/out/prefix_tree.success,target=/mnt/prefix_tree.success \
    --mount=from=priority_queue,src=/out/priority_queue.success,target=/mnt/priority_queue.success \
    --mount=from=segment_tree,src=/out/segment_tree.success,target=/mnt/segment_tree.success \
    --mount=from=skiplist,src=/out/skiplist.success,target=/mnt/skiplist.success \
    --mount=from=sprague_grundy,src=/out/sprague_grundy.success,target=/mnt/sprague_grundy.success \
    --mount=from=suffix_array,src=/out/suffix_array.success,target=/mnt/suffix_array.success \
    --mount=from=topological_sort,src=/out/topological_sort.success,target=/mnt/topological_sort.success \
    --mount=from=two_sat,src=/out/two_sat.success,target=/mnt/two_sat.success \
    --mount=from=union_find,src=/out/union_find.success,target=/mnt/union_find.success \
    ls /mnt/*.success | wc -l > /tmp/count && \
    echo "All $(cat /tmp/count) algorithms tested successfully"
