<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Reference - Cpp</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 9pt;
            line-height: 1.2;
            margin: 0;
            padding: 0;
            color: #000;
            background: #fff;
        }

        @media print {
            @page {
                size: A4;
                margin: 1cm 0.8cm;
            }

            body {
                font-size: 9pt;
            }

            .toc-page {
                page-break-after: always;
                page-break-inside: avoid;
            }

            .blank-page {
                page-break-after: always;
                height: 100vh;
            }

            .algorithm-page {
                page-break-before: always;
            }

            .algorithm-page:last-child {
                page-break-after: auto;
                break-after: auto;
            }

            .no-break {
                page-break-inside: avoid;
            }
        }

        @media screen {
            body {
                max-width: 21cm;
                margin: 0 auto;
                padding: 2cm;
                background: #f5f5f5;
            }

            .toc-page, .blank-page, .algorithm-page {
                page-break-after: unset !important;
                page-break-before: unset !important;
                page-break-inside: unset !important;
                break-after: unset !important;
                break-before: unset !important;
                break-inside: unset !important;
            }
        }

        h1 {
            font-size: 14pt;
            margin: 0 0 0.5em 0;
            text-align: center;
            font-weight: bold;
        }

        h2 {
            font-size: 14pt;
            margin: 1.5em 0 0.5em 0;
            font-weight: bold;
            border-bottom: 1px solid #333;
            padding-bottom: 0.2em;
        }

        .toc-content {
            font-size: 9pt;
        }

        .toc-item {
            margin: 0.1em 0;
            padding: 0.05em 0;
            border-bottom: 1px dotted #ccc;
        }

        .toc-name {
            font-weight: bold;
        }

        .blank-page {
            /* Height set in print media query only */
        }

        .algorithm-header {
            margin-bottom: 1em;
        }

        .algorithm-filename {
            font-size: 9pt;
            color: #666;
            margin-bottom: 0.5em;
        }

        pre {
            margin: 0;
            padding: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
        }

        code {
            font-family: inherit;
            font-size: inherit;
        }

        /* Syntax highlighting classes */
        .highlight { background: transparent; }
        .highlight .c { color: #408080; font-style: italic } /* Comment */
        .highlight .k { color: #008000; font-weight: bold } /* Keyword */
        .highlight .o { color: #666666 } /* Operator */
        .highlight .n { color: #000000 } /* Name */
        .highlight .s { color: #BA2121 } /* String */
        .highlight .nb { color: #008000 } /* Name.Builtin */
        .highlight .nf { color: #0000FF } /* Name.Function */
        .highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
    </style>
</head>
<body>
    <!-- Table of Contents -->
    <div class="toc-page">
        <h1>Algorithm Reference - Cpp</h1>
        <div class="toc-content">
            <div class="toc-item">
                <span class="toc-name">Bipartite Match</span>
            </div>
            <div class="toc-item">
                <span class="toc-name">Dijkstra</span>
            </div>
            <div class="toc-item">
                <span class="toc-name">Edmonds Karp</span>
            </div>
            <div class="toc-item">
                <span class="toc-name">Fenwick Tree</span>
            </div>
            <div class="toc-item">
                <span class="toc-name">Kmp</span>
            </div>
            <div class="toc-item">
                <span class="toc-name">Lca</span>
            </div>
            <div class="toc-item">
                <span class="toc-name">Polygon Area</span>
            </div>
            <div class="toc-item">
                <span class="toc-name">Prefix Tree</span>
            </div>
            <div class="toc-item">
                <span class="toc-name">Priority Queue</span>
            </div>
            <div class="toc-item">
                <span class="toc-name">Segment Tree</span>
            </div>
            <div class="toc-item">
                <span class="toc-name">Topological Sort</span>
            </div>
            <div class="toc-item">
                <span class="toc-name">Union Find</span>
            </div>
        </div>
    </div>

    <!-- Algorithm pages -->
    <div class="algorithm-page">
        <div class="algorithm-header">
            <h2>Bipartite Match</h2>
            <div class="algorithm-filename">bipartite_match.cpp</div>
        </div>
        <pre><code>/*
A bipartite matching algorithm finds the largest set of pairings between two disjoint vertex sets U and V
in a bipartite graph such that no vertex is in more than one pair.

Augmenting paths: repeatedly search for a path that alternates between unmatched and matched edges,
starting and ending at free vertices. Flipping the edges along such a path increases the matching size by 1.

Time complexity: O(V · E), where V is the number of vertices and E the number of edges.
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;
#include &lt;cassert&gt;

template&lt;typename SourceT, typename SinkT&gt;
class BipartiteMatch {
private:
    std::map&lt;SourceT, std::vector&lt;SinkT&gt;&gt; edges;
    std::map&lt;SourceT, SinkT&gt; used_sources;
    std::map&lt;SinkT, SourceT&gt; used_sinks;
    std::map&lt;SourceT, int&gt; coloring;

    void flip(std::vector&lt;SourceT&gt;&amp; source_stack, std::vector&lt;SinkT&gt;&amp; sink_stack) {
        while (!source_stack.empty()) {
            used_sources[source_stack.back()] = sink_stack.back();
            used_sinks[sink_stack.back()] = source_stack.back();
            source_stack.pop_back();
            sink_stack.pop_back();
        }
    }

    bool update(SourceT start_source, int cur_color) {
        if (used_sources.find(start_source) != used_sources.end()) {
            return false;
        }

        std::vector&lt;SourceT&gt; source_stack = {start_source};
        std::vector&lt;SinkT&gt; sink_stack;
        std::vector&lt;size_t&gt; index_stack = {0};

        while (true) {
            SourceT source = source_stack.back();
            size_t index = index_stack.back();
            index_stack.pop_back();

            if (index == edges[source].size()) {
                if (index_stack.empty()) {
                    return false;
                }
                source_stack.pop_back();
                sink_stack.pop_back();
                continue;
            }
            index_stack.push_back(index + 1);

            SinkT sink = edges[source][index];
            sink_stack.push_back(sink);

            if (used_sinks.find(sink) == used_sinks.end()) {
                flip(source_stack, sink_stack);
                return true;
            }

            source = used_sinks[sink];
            if (coloring[source] == cur_color) {
                sink_stack.pop_back();
            } else {
                coloring[source] = cur_color;
                source_stack.push_back(source);
                index_stack.push_back(0);
            }
        }
    }

public:
    std::map&lt;SourceT, SinkT&gt; match;

    BipartiteMatch(const std::vector&lt;std::pair&lt;SourceT, SinkT&gt;&gt;&amp; edge_list) {
        for (const auto&amp; [source, sink] : edge_list) {
            edges[source].push_back(sink);
        }

        // Get ordered sources for deterministic behavior
        std::vector&lt;SourceT&gt; ordered_sources;
        for (const auto&amp; [source, _] : edges) {
            ordered_sources.push_back(source);
            coloring[source] = 0;
        }

        // Initial pass
        for (const auto&amp; [source, sink] : edge_list) {
            if (used_sources.find(source) == used_sources.end() &amp;&amp;
                used_sinks.find(sink) == used_sinks.end()) {
                used_sources[source] = sink;
                used_sinks[sink] = source;
                break;
            }
        }

        bool progress = true;
        int cur_color = 1;
        while (progress) {
            progress = false;
            for (const auto&amp; source : ordered_sources) {
                if (update(source, cur_color)) {
                    progress = true;
                }
            }
            cur_color++;
        }

        match = used_sources;
    }
};

void test_main() {
    BipartiteMatch&lt;int, std::string&gt; b({
        {1, &quot;X&quot;}, {2, &quot;Y&quot;}, {3, &quot;X&quot;}, {1, &quot;Z&quot;}, {2, &quot;Z&quot;}, {3, &quot;Y&quot;}
    });
    assert(b.match.size() == 3);
    assert(b.match[1] == &quot;Z&quot;);
    assert(b.match[2] == &quot;Y&quot;);
    assert(b.match[3] == &quot;X&quot;);
}
</code></pre>
    </div>
    <div class="algorithm-page">
        <div class="algorithm-header">
            <h2>Dijkstra</h2>
            <div class="algorithm-filename">dijkstra.cpp</div>
        </div>
        <pre><code>/*
Dijkstra&#x27;s algorithm for single-source shortest path in weighted graphs.

Finds shortest paths from a source vertex to all other vertices in a graph with
non-negative edge weights. Uses a priority queue (heap) for efficient vertex selection.

Time complexity: O((V + E) log V) with binary heap, where V is vertices and E is edges.
Space complexity: O(V + E) for the graph representation and auxiliary data structures.
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;optional&gt;
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;limits&gt;

template&lt;typename NodeT, typename WeightT&gt;
class Dijkstra {
private:
    WeightT infinity;
    WeightT zero;
    std::map&lt;NodeT, std::vector&lt;std::pair&lt;NodeT, WeightT&gt;&gt;&gt; graph;

public:
    Dijkstra(WeightT infinity, WeightT zero) : infinity(infinity), zero(zero) {}

    void add_edge(NodeT u, NodeT v, WeightT weight) {
        graph[u].push_back({v, weight});
    }

    std::pair&lt;std::map&lt;NodeT, WeightT&gt;, std::map&lt;NodeT, std::optional&lt;NodeT&gt;&gt;&gt;
    shortest_paths(NodeT source) {
        std::map&lt;NodeT, WeightT&gt; distances;
        std::map&lt;NodeT, std::optional&lt;NodeT&gt;&gt; predecessors;
        distances[source] = zero;
        predecessors[source] = std::nullopt;

        // Min heap: pair of (distance, node)
        std::priority_queue&lt;
            std::pair&lt;WeightT, NodeT&gt;,
            std::vector&lt;std::pair&lt;WeightT, NodeT&gt;&gt;,
            std::greater&lt;std::pair&lt;WeightT, NodeT&gt;&gt;
        &gt; pq;

        pq.push({zero, source});
        std::set&lt;NodeT&gt; visited;

        while (!pq.empty()) {
            auto [current_dist, u] = pq.top();
            pq.pop();

            if (visited.count(u)) {
                continue;
            }
            visited.insert(u);

            if (graph.find(u) == graph.end()) {
                continue;
            }

            for (const auto&amp; [v, weight] : graph[u]) {
                WeightT new_dist = current_dist + weight;

                if (distances.find(v) == distances.end() || new_dist &lt; distances[v]) {
                    distances[v] = new_dist;
                    predecessors[v] = u;
                    pq.push({new_dist, v});
                }
            }
        }

        return {distances, predecessors};
    }

    std::optional&lt;std::vector&lt;NodeT&gt;&gt; shortest_path(NodeT source, NodeT target) {
        auto [distances, predecessors] = shortest_paths(source);

        if (predecessors.find(target) == predecessors.end()) {
            return std::nullopt;
        }

        std::vector&lt;NodeT&gt; path;
        std::optional&lt;NodeT&gt; current = target;

        while (current.has_value()) {
            path.push_back(current.value());
            current = predecessors[current.value()];
        }

        std::reverse(path.begin(), path.end());
        return path;
    }
};

void test_main() {
    Dijkstra&lt;std::string, double&gt; d(std::numeric_limits&lt;double&gt;::infinity(), 0.0);
    d.add_edge(&quot;A&quot;, &quot;B&quot;, 4.0);
    d.add_edge(&quot;A&quot;, &quot;C&quot;, 2.0);
    d.add_edge(&quot;B&quot;, &quot;C&quot;, 1.0);
    d.add_edge(&quot;B&quot;, &quot;D&quot;, 5.0);
    d.add_edge(&quot;C&quot;, &quot;D&quot;, 8.0);

    auto [distances, _] = d.shortest_paths(&quot;A&quot;);
    assert(distances[&quot;D&quot;] == 9.0);

    auto path = d.shortest_path(&quot;A&quot;, &quot;D&quot;);
    assert(path.has_value());
    assert(path.value() == std::vector&lt;std::string&gt;({&quot;A&quot;, &quot;B&quot;, &quot;D&quot;}));
}
</code></pre>
    </div>
    <div class="algorithm-page">
        <div class="algorithm-header">
            <h2>Edmonds Karp</h2>
            <div class="algorithm-filename">edmonds_karp.cpp</div>
        </div>
        <pre><code>/*
Edmonds-Karp is a specialization of the Ford-Fulkerson method for computing the maximum flow in a directed graph.

* It repeatedly searches for an augmenting path from source to sink.
* The search is done with BFS, guaranteeing the path found is the shortest (fewest edges).
* Each augmentation increases the total flow, and each edge&#x27;s residual capacity is updated.
* The algorithm terminates when no augmenting path exists.

Time complexity: O(V · E²), where V is the number of vertices and E the number of edges.
*/

#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;limits&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;

template&lt;typename T&gt;
class EdmondsKarp {
private:
    int n;
    std::vector&lt;std::vector&lt;T&gt;&gt; capacity;
    std::vector&lt;std::vector&lt;T&gt;&gt; flow;
    T total_flow;

public:
    EdmondsKarp(int vertices) : n(vertices), total_flow(0) {
        capacity.assign(n, std::vector&lt;T&gt;(n, 0));
        flow.assign(n, std::vector&lt;T&gt;(n, 0));
    }

    void add_edge(int from, int to, T cap) {
        capacity[from][to] += cap;
    }

    bool bfs(int source, int sink, std::vector&lt;int&gt;&amp; parent) {
        std::vector&lt;bool&gt; visited(n, false);
        std::queue&lt;int&gt; q;
        q.push(source);
        visited[source] = true;
        parent[source] = -1;

        while (!q.empty()) {
            int u = q.front();
            q.pop();

            for (int v = 0; v &lt; n; v++) {
                // Check residual capacity: forward capacity minus forward flow, plus backward flow
                T residual = capacity[u][v] - flow[u][v];
                if (!visited[v] &amp;&amp; residual &gt; 0) {
                    q.push(v);
                    parent[v] = u;
                    visited[v] = true;
                    if (v == sink) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    T max_flow(int source, int sink) {
        total_flow = 0;
        std::vector&lt;int&gt; parent(n);

        while (bfs(source, sink, parent)) {
            T path_flow = std::numeric_limits&lt;T&gt;::max();

            // Find minimum residual capacity along the path
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                path_flow = std::min(path_flow, capacity[u][v] - flow[u][v]);
            }

            // Add path flow to overall flow
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                flow[u][v] += path_flow;
                flow[v][u] -= path_flow;
            }

            total_flow += path_flow;
        }

        return total_flow;
    }

    T get_total_flow() const {
        return total_flow;
    }
};

void test_main() {
    EdmondsKarp&lt;int&gt; e(4);
    e.add_edge(0, 1, 10);
    e.add_edge(0, 2, 8);
    e.add_edge(1, 2, 2);
    e.add_edge(1, 3, 5);
    e.add_edge(2, 3, 7);
    assert(e.max_flow(0, 3) == 12);
}
</code></pre>
    </div>
    <div class="algorithm-page">
        <div class="algorithm-header">
            <h2>Fenwick Tree</h2>
            <div class="algorithm-filename">fenwick_tree.cpp</div>
        </div>
        <pre><code>/*
Fenwick tree (Binary Indexed Tree) for efficient range sum queries and point updates.

A Fenwick tree maintains cumulative frequency information and supports two main operations:
* update(i, delta): add delta to the element at index i
* query(i): return the sum of elements from index 0 to i (inclusive)
* range_query(left, right): return the sum of elements from left to right (inclusive)

The tree uses a clever indexing scheme based on the binary representation of indices
to achieve logarithmic time complexity for both operations.

Time complexity: O(log n) for update and query operations.
Space complexity: O(n) where n is the size of the array.
*/

#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;

template&lt;typename T&gt;
class FenwickTree {
private:
    int size;
    T zero;
    std::vector&lt;T&gt; tree; // 1-indexed tree for easier bit manipulation

public:
    FenwickTree(int size, T zero) : size(size), zero(zero), tree(size + 1, zero) {}

    static FenwickTree from_array(const std::vector&lt;T&gt;&amp; arr, T zero) {
        int n = arr.size();
        FenwickTree ft(n, zero);

        // Compute prefix sums
        std::vector&lt;T&gt; prefix(n + 1, zero);
        for (int i = 0; i &lt; n; i++) {
            prefix[i + 1] = prefix[i] + arr[i];
        }

        // Build tree in O(n): each tree[i] contains sum of range [i - (i &amp; -i) + 1, i]
        for (int i = 1; i &lt;= n; i++) {
            int range_start = i - (i &amp; (-i)) + 1;
            ft.tree[i] = prefix[i] - prefix[range_start - 1];
        }

        return ft;
    }

    void update(int index, T delta) {
        if (index &lt; 0 || index &gt;= size) {
            throw std::out_of_range(&quot;Index out of bounds&quot;);
        }

        // Convert to 1-indexed
        index++;
        while (index &lt;= size) {
            tree[index] = tree[index] + delta;
            // Move to next index by adding the lowest set bit
            index += index &amp; (-index);
        }
    }

    T query(int index) {
        if (index &lt; 0 || index &gt;= size) {
            throw std::out_of_range(&quot;Index out of bounds&quot;);
        }

        // Convert to 1-indexed
        index++;
        T result = zero;
        while (index &gt; 0) {
            result = result + tree[index];
            // Move to parent by removing the lowest set bit
            index -= index &amp; (-index);
        }
        return result;
    }

    T range_query(int left, int right) {
        if (left &gt; right || left &lt; 0 || right &gt;= size) {
            return zero;
        }
        if (left == 0) {
            return query(right);
        }
        return query(right) - query(left - 1);
    }

    // Optional functionality (not always needed during competition)

    T get_value(int index) {
        if (index &lt; 0 || index &gt;= size) {
            throw std::out_of_range(&quot;Index out of bounds&quot;);
        }
        if (index == 0) {
            return query(0);
        }
        return query(index) - query(index - 1);
    }

    // Find smallest index &gt;= start_index with value &gt; zero (REQUIRES: all updates are non-negative)
    int first_nonzero_index(int start_index) {
        start_index = std::max(start_index, 0);
        if (start_index &gt;= size) {
            return -1;  // Use -1 to indicate &quot;not found&quot; in C++
        }

        T prefix_before = (start_index &gt; 0) ? query(start_index - 1) : zero;
        T total = query(size - 1);
        if (total == prefix_before) {
            return -1;
        }

        // Fenwick lower_bound: first idx with prefix_sum(idx) &gt; prefix_before
        int idx = 0;  // 1-based cursor
        T cur = zero;  // running prefix at &#x27;idx&#x27;
        int bit = 1;
        while (bit &lt;= size) bit &lt;&lt;= 1;
        bit &gt;&gt;= 1;

        while (bit &gt; 0) {
            int nxt = idx + bit;
            if (nxt &lt;= size) {
                T cand = cur + tree[nxt];
                if (cand &lt;= prefix_before) {  // move right while prefix &lt;= target
                    cur = cand;
                    idx = nxt;
                }
            }
            bit &gt;&gt;= 1;
        }

        // idx is the largest position with prefix &lt;= prefix_before (1-based).
        // The answer is idx (converted to 0-based).
        return idx;
    }

    int length() const {
        return size;
    }
};

void test_main() {
    FenwickTree&lt;int&gt; f(5, 0);
    f.update(0, 7);
    f.update(2, 13);
    f.update(4, 19);
    assert(f.query(4) == 39);
    assert(f.range_query(1, 3) == 13);

    // Optional functionality (not always needed during competition)

    assert(f.get_value(2) == 13);
    auto g = FenwickTree&lt;int&gt;::from_array({1, 2, 3, 4, 5}, 0);
    assert(g.query(4) == 15);
}
</code></pre>
    </div>
    <div class="algorithm-page">
        <div class="algorithm-header">
            <h2>Kmp</h2>
            <div class="algorithm-filename">kmp.cpp</div>
        </div>
        <pre><code>/*
Knuth-Morris-Pratt (KMP) algorithm for efficient string pattern matching.

Finds all occurrences of a pattern string within a text string using a failure function
to avoid redundant comparisons. The preprocessing phase builds a table that allows
skipping characters during mismatches.

Time complexity: O(n + m) where n is text length and m is pattern length.
Space complexity: O(m) for the failure function table.
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cassert&gt;

std::vector&lt;int&gt; compute_failure_function(const std::string&amp; pattern) {
    /*
    Compute the failure function for KMP algorithm.

    failure[i] = length of longest proper prefix of pattern[0:i+1]
    that is also a suffix of pattern[0:i+1]
    */
    int m = pattern.length();
    std::vector&lt;int&gt; failure(m, 0);
    int j = 0;

    for (int i = 1; i &lt; m; i++) {
        while (j &gt; 0 &amp;&amp; pattern[i] != pattern[j]) {
            j = failure[j - 1];
        }

        if (pattern[i] == pattern[j]) {
            j++;
        }

        failure[i] = j;
    }

    return failure;
}

std::vector&lt;int&gt; kmp_search(const std::string&amp; text, const std::string&amp; pattern) {
    /*
    Find all starting positions where pattern occurs in text.

    Returns a list of 0-indexed positions where pattern begins in text.
    */
    if (pattern.empty()) {
        return {};
    }

    int n = text.length(), m = pattern.length();
    if (m &gt; n) {
        return {};
    }

    std::vector&lt;int&gt; failure = compute_failure_function(pattern);
    std::vector&lt;int&gt; matches;
    int j = 0;  // index for pattern

    for (int i = 0; i &lt; n; i++) {  // index for text
        while (j &gt; 0 &amp;&amp; text[i] != pattern[j]) {
            j = failure[j - 1];
        }

        if (text[i] == pattern[j]) {
            j++;
        }

        if (j == m) {
            matches.push_back(i - m + 1);
            j = failure[j - 1];
        }
    }

    return matches;
}

int kmp_count(const std::string&amp; text, const std::string&amp; pattern) {
    /* Count number of occurrences of pattern in text. */
    return kmp_search(text, pattern).size();
}

void test_main() {
    std::string text = &quot;ababcababa&quot;;
    std::string pattern = &quot;aba&quot;;
    std::vector&lt;int&gt; matches = kmp_search(text, pattern);
    assert(matches == std::vector&lt;int&gt;({0, 5, 7}));
    assert(kmp_count(text, pattern) == 3);

    // Test failure function
    std::vector&lt;int&gt; failure = compute_failure_function(&quot;abcabcab&quot;);
    assert(failure == std::vector&lt;int&gt;({0, 0, 0, 1, 2, 3, 4, 5}));
}
</code></pre>
    </div>
    <div class="algorithm-page">
        <div class="algorithm-header">
            <h2>Lca</h2>
            <div class="algorithm-filename">lca.cpp</div>
        </div>
        <pre><code>/*
Lowest Common Ancestor (LCA) using binary lifting preprocessing.

Finds the lowest common ancestor of two nodes in a tree efficiently after O(n log n)
preprocessing. Binary lifting allows answering LCA queries in O(log n) time by
maintaining ancestors at powers-of-2 distances.

Time complexity: O(n log n) preprocessing, O(log n) per LCA query.
Space complexity: O(n log n) for the binary lifting table.
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;cassert&gt;

template&lt;typename NodeT&gt;
class LCA {
private:
    NodeT root;
    std::map&lt;NodeT, std::vector&lt;NodeT&gt;&gt; graph;
    std::map&lt;NodeT, int&gt; depth;
    std::map&lt;NodeT, std::map&lt;int, NodeT&gt;&gt; up;  // up[node][i] = 2^i-th ancestor
    std::set&lt;NodeT&gt; has_parent;  // nodes that have a parent
    int max_log;

    void dfs_depth(NodeT node, bool has_par, NodeT par, int d) {
        depth[node] = d;
        for (const auto&amp; neighbor : graph[node]) {
            if (!has_par || neighbor != par) {
                dfs_depth(neighbor, true, node, d + 1);
            }
        }
    }

    void dfs_parents(NodeT node, bool has_par, NodeT par) {
        if (has_par) {
            up[node][0] = par;
            has_parent.insert(node);
        }
        for (const auto&amp; neighbor : graph[node]) {
            if (!has_par || neighbor != par) {
                dfs_parents(neighbor, true, node);
            }
        }
    }

public:
    LCA(NodeT root) : root(root), max_log(0) {}

    void add_edge(NodeT u, NodeT v) {
        graph[u].push_back(v);
        graph[v].push_back(u);
    }

    void preprocess() {
        // Find max depth to determine log table size
        dfs_depth(root, false, root, 0);

        int n = depth.size();
        max_log = 0;
        while ((1 &lt;&lt; max_log) &lt;= n) {
            max_log++;
        }

        // Fill first column (direct parents)
        dfs_parents(root, false, root);

        // Fill binary lifting table
        for (int j = 1; j &lt; max_log; j++) {
            for (const auto&amp; [node, _] : depth) {
                if (up[node].count(j - 1)) {
                    NodeT parent_j_minus_1 = up[node][j - 1];
                    if (up[parent_j_minus_1].count(j - 1)) {
                        up[node][j] = up[parent_j_minus_1][j - 1];
                    }
                }
            }
        }
    }

    NodeT lca(NodeT u, NodeT v) {
        if (depth[u] &lt; depth[v]) {
            std::swap(u, v);
        }

        // Bring u to same level as v
        int diff = depth[u] - depth[v];
        for (int i = 0; i &lt; max_log; i++) {
            if ((diff &gt;&gt; i) &amp; 1) {
                if (up[u].count(i)) {
                    u = up[u][i];
                }
            }
        }

        if (u == v) {
            return u;
        }

        // Binary search for LCA
        for (int i = max_log - 1; i &gt;= 0; i--) {
            bool u_has = up[u].count(i);
            bool v_has = up[v].count(i);
            if (u_has &amp;&amp; v_has &amp;&amp; up[u][i] != up[v][i]) {
                u = up[u][i];
                v = up[v][i];
            }
        }

        if (!up[u].count(0)) {
            throw std::runtime_error(&quot;LCA computation failed - invalid tree structure&quot;);
        }
        return up[u][0];
    }

    int distance(NodeT u, NodeT v) {
        NodeT lca_node = lca(u, v);
        return depth[u] + depth[v] - 2 * depth[lca_node];
    }
};

void test_main() {
    LCA&lt;int&gt; lca(1);
    std::vector&lt;std::pair&lt;int, int&gt;&gt; edges = {{1, 2}, {1, 3}, {2, 4}, {2, 5}, {3, 6}};
    for (const auto&amp; [u, v] : edges) {
        lca.add_edge(u, v);
    }

    lca.preprocess();

    assert(lca.lca(4, 5) == 2);
    assert(lca.lca(4, 6) == 1);
    assert(lca.distance(4, 6) == 4);
}
</code></pre>
    </div>
    <div class="algorithm-page">
        <div class="algorithm-header">
            <h2>Polygon Area</h2>
            <div class="algorithm-filename">polygon_area.cpp</div>
        </div>
        <pre><code>/*
Shoelace formula (Gauss&#x27;s area formula) for computing the area of a polygon.

Computes the area of a simple polygon given its vertices in order (clockwise or
counter-clockwise). Works for both convex and concave polygons.

The formula: Area = ½ |∑(xᵢ × yᵢ₊₁ - xᵢ₊₁ × yᵢ)|

Time complexity: O(n) where n is the number of vertices.
Space complexity: O(1) additional space.
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;cassert&gt;

struct Point {
    double x, y;
    Point(double x = 0, double y = 0) : x(x), y(y) {}
};

double polygon_area(const std::vector&lt;Point&gt;&amp; vertices) {
    /*
    Calculate the area of a polygon using the Shoelace formula.

    Args:
        vertices: Vector of points in order (clockwise or counter-clockwise)

    Returns:
        The area of the polygon (always positive)
    */
    if (vertices.size() &lt; 3) {
        return 0.0;
    }

    int n = vertices.size();
    double area = 0.0;

    for (int i = 0; i &lt; n; i++) {
        int j = (i + 1) % n;
        area += vertices[i].x * vertices[j].y;
        area -= vertices[j].x * vertices[i].y;
    }

    return std::abs(area) / 2.0;
}

double polygon_signed_area(const std::vector&lt;Point&gt;&amp; vertices) {
    /*
    Calculate the signed area of a polygon.

    Returns positive area for counter-clockwise vertices, negative for clockwise.
    Useful for determining polygon orientation.

    Args:
        vertices: Vector of points in order

    Returns:
        The signed area (positive for CCW, negative for CW)
    */
    if (vertices.size() &lt; 3) {
        return 0.0;
    }

    int n = vertices.size();
    double area = 0.0;

    for (int i = 0; i &lt; n; i++) {
        int j = (i + 1) % n;
        area += vertices[i].x * vertices[j].y;
        area -= vertices[j].x * vertices[i].y;
    }

    return area / 2.0;
}

bool is_clockwise(const std::vector&lt;Point&gt;&amp; vertices) {
    /* Check if polygon vertices are in clockwise order. */
    return polygon_signed_area(vertices) &lt; 0;
}

void test_main() {
    // Simple square with side length 2
    std::vector&lt;Point&gt; square = {{0.0, 0.0}, {2.0, 0.0}, {2.0, 2.0}, {0.0, 2.0}};
    assert(polygon_area(square) == 4.0);

    // Triangle with base 3 and height 4
    std::vector&lt;Point&gt; triangle = {{0.0, 0.0}, {3.0, 0.0}, {1.5, 4.0}};
    assert(polygon_area(triangle) == 6.0);

    // Test orientation
    std::vector&lt;Point&gt; ccw_square = {{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}, {0.0, 1.0}};
    assert(!is_clockwise(ccw_square));
}
</code></pre>
    </div>
    <div class="algorithm-page">
        <div class="algorithm-header">
            <h2>Prefix Tree</h2>
            <div class="algorithm-filename">prefix_tree.cpp</div>
        </div>
        <pre><code>/*
Write-only prefix tree (trie) for efficient string storage and retrieval.

Supports adding strings and finding all strings that are prefixes of a given string.
The tree structure allows for efficient storage of strings with common prefixes.

Time complexity: O(m) for add and find operations, where m is the length of the string.
Space complexity: O(ALPHABET_SIZE * N * M) in the worst case, where N is the number
of strings and M is the average length of strings.
*/

#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;

class PrefixTree {
private:
    std::vector&lt;std::string&gt; keys;
    std::vector&lt;PrefixTree*&gt; values;

public:
    PrefixTree() {}

    ~PrefixTree() {
        for (auto* child : values) {
            delete child;
        }
    }

    void pp(int indent = 0) {
        // Pretty-print tree structure for debugging
        for (size_t i = 0; i &lt; keys.size(); i++) {
            for (int j = 0; j &lt; indent; j++) std::cout &lt;&lt; &quot; &quot;;
            std::cout &lt;&lt; keys[i] &lt;&lt; &quot;: &quot; &lt;&lt; (values[i] == nullptr ? &quot;-&quot; : &quot;&quot;) &lt;&lt; std::endl;
            if (values[i] != nullptr) {
                values[i]-&gt;pp(indent + 2);
            }
        }
    }

    void find_all(const std::string&amp; s, int offset, std::vector&lt;int&gt;&amp; append_to) {
        // Find all strings in tree that are prefixes of s[offset:]. Appends end positions.
        if (!keys.empty() &amp;&amp; keys[0] == &quot;&quot;) {
            append_to.push_back(offset);
        }
        if (offset &gt;= s.length()) {
            return;
        }
        std::string target_char = s.substr(offset, 1);
        auto it = std::lower_bound(keys.begin(), keys.end(), target_char);
        int index = it - keys.begin();
        if (index == keys.size()) {
            return;
        }
        std::string key_substr = s.substr(offset, keys[index].length());
        if (key_substr == keys[index]) {
            PrefixTree* pt = values[index];
            if (pt == nullptr) {
                append_to.push_back(offset + keys[index].length());
            } else {
                pt-&gt;find_all(s, offset + keys[index].length(), append_to);
            }
        }
    }

    int max_len() {
        // Return length of longest string in tree
        int result = 0;
        for (size_t i = 0; i &lt; keys.size(); i++) {
            result = std::max(result, (int)keys[i].length() + (values[i] == nullptr ? 0 : values[i]-&gt;max_len()));
        }
        return result;
    }

    void add(const std::string&amp; s) {
        // Add string to tree
        if (s.empty() || keys.empty()) {
            keys.insert(keys.begin(), s);
            values.insert(values.begin(), nullptr);
            return;
        }

        auto it = std::lower_bound(keys.begin(), keys.end(), s);
        int pos = it - keys.begin();
        if (pos &gt; 0 &amp;&amp; !keys[pos - 1].empty() &amp;&amp; keys[pos - 1][0] == s[0]) {
            pos--;
        }
        if (pos &lt; keys.size() &amp;&amp; !keys[pos].empty() &amp;&amp; keys[pos][0] == s[0]) {
            // Merge
            if (s.find(keys[pos]) == 0 &amp;&amp; s.length() &gt;= keys[pos].length()) {
                // s starts with keys[pos]
                PrefixTree* pt = values[pos];
                if (pt == nullptr) {
                    PrefixTree* child = new PrefixTree();
                    child-&gt;keys.push_back(&quot;&quot;);
                    child-&gt;values.push_back(nullptr);
                    values[pos] = pt = child;
                }
                pt-&gt;add(s.substr(keys[pos].length()));
            } else if (keys[pos].find(s) == 0 &amp;&amp; keys[pos].length() &gt;= s.length()) {
                // keys[pos] starts with s
                PrefixTree* child = new PrefixTree();
                child-&gt;keys.push_back(&quot;&quot;);
                child-&gt;values.push_back(nullptr);
                child-&gt;keys.push_back(keys[pos].substr(s.length()));
                child-&gt;values.push_back(values[pos]);
                keys[pos] = s;
                values[pos] = child;
            } else {
                // Find common prefix
                int prefix = 1;
                while (prefix &lt; s.length() &amp;&amp; prefix &lt; keys[pos].length() &amp;&amp; s[prefix] == keys[pos][prefix]) {
                    prefix++;
                }
                PrefixTree* child = new PrefixTree();
                if (s &lt; keys[pos]) {
                    child-&gt;keys.push_back(s.substr(prefix));
                    child-&gt;values.push_back(nullptr);
                }
                child-&gt;keys.push_back(keys[pos].substr(prefix));
                child-&gt;values.push_back(values[pos]);
                if (s &gt;= keys[pos]) {
                    child-&gt;keys.push_back(s.substr(prefix));
                    child-&gt;values.push_back(nullptr);
                }
                keys[pos] = s.substr(0, prefix);
                values[pos] = child;
            }
        } else {
            keys.insert(keys.begin() + pos, s);
            values.insert(values.begin() + pos, nullptr);
        }
    }
};

void test_main() {
    PrefixTree p;
    p.add(&quot;cat&quot;);
    p.add(&quot;car&quot;);
    p.add(&quot;card&quot;);
    std::vector&lt;int&gt; l;
    p.find_all(&quot;card&quot;, 0, l);
    assert(l.size() == 2 &amp;&amp; l[0] == 3 &amp;&amp; l[1] == 4);
    assert(p.max_len() == 4);
}
</code></pre>
    </div>
    <div class="algorithm-page">
        <div class="algorithm-header">
            <h2>Priority Queue</h2>
            <div class="algorithm-filename">priority_queue.cpp</div>
        </div>
        <pre><code>/*
Priority queue implementation using a binary heap.

This module provides a generic priority queue that supports adding items with priorities,
updating priorities, removing items, and popping the item with the lowest priority.
The implementation uses C++ std::priority_queue for efficient heap operations.

Time complexity: O(log n) for add/update and pop operations, O(log n) for remove.
Space complexity: O(n) where n is the number of items in the queue.
*/

#include &lt;queue&gt;
#include &lt;unordered_map&gt;
#include &lt;functional&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;utility&gt;

template&lt;typename KeyT, typename PriorityT&gt;
class PriorityQueue {
private:
    struct Entry {
        PriorityT priority;
        KeyT key;
        size_t version;

        Entry(PriorityT p, KeyT k, size_t v) : priority(p), key(k), version(v) {}

        // For min-heap behavior (lowest priority first)
        bool operator&gt;(const Entry&amp; other) const {
            return priority &gt; other.priority;
        }
    };

    std::priority_queue&lt;Entry, std::vector&lt;Entry&gt;, std::greater&lt;Entry&gt;&gt; pq;
    std::unordered_map&lt;KeyT, size_t&gt; key_versions;  // Maps keys to their current version
    size_t next_version;
    int size_count;

public:
    PriorityQueue() : next_version(0), size_count(0) {}

    void set(const KeyT&amp; key, const PriorityT&amp; priority) {
        // Add a new task or update the priority of an existing task
        if (key_versions.find(key) != key_versions.end()) {
            // Key exists, this will invalidate the old entry
            size_count--; // We&#x27;ll increment it back below
        }

        size_count++;
        size_t version = next_version++;
        key_versions[key] = version;
        pq.push(Entry(priority, key, version));
    }

    void remove(const KeyT&amp; key) {
        // Mark an existing task as removed by updating its version
        auto it = key_versions.find(key);
        if (it == key_versions.end()) {
            throw std::runtime_error(&quot;Key not found in priority queue&quot;);
        }
        key_versions.erase(it);
        size_count--;
    }

    std::pair&lt;KeyT, PriorityT&gt; pop() {
        // Remove and return the lowest priority task. Throw exception if empty.
        while (!pq.empty()) {
            Entry top = pq.top();
            pq.pop();

            // Check if this entry is still valid (not removed/updated)
            auto it = key_versions.find(top.key);
            if (it != key_versions.end() &amp;&amp; it-&gt;second == top.version) {
                key_versions.erase(it);
                size_count--;
                return std::make_pair(top.key, top.priority);
            }
        }
        throw std::runtime_error(&quot;pop from an empty priority queue&quot;);
    }

    std::pair&lt;KeyT, PriorityT&gt; peek() {
        // Return the lowest priority task without removing. Returns empty result throws if empty.
        while (!pq.empty()) {
            Entry top = pq.top();

            // Check if this entry is still valid (not removed/updated)
            auto it = key_versions.find(top.key);
            if (it != key_versions.end() &amp;&amp; it-&gt;second == top.version) {
                return std::make_pair(top.key, top.priority);
            }
            // Remove the invalid entry from the top
            pq.pop();
        }
        throw std::runtime_error(&quot;peek from an empty priority queue&quot;);
    }

    bool contains(const KeyT&amp; key) const {
        return key_versions.find(key) != key_versions.end();
    }

    int size() const {
        return size_count;
    }

    bool empty() const {
        return size_count == 0;
    }
};

void test_main() {
    PriorityQueue&lt;std::string, int&gt; p;
    p.set(&quot;x&quot;, 15);
    p.set(&quot;y&quot;, 23);
    p.set(&quot;z&quot;, 8);
    auto peek_result = p.peek();
    assert(peek_result.first == &quot;z&quot; &amp;&amp; peek_result.second == 8);
    auto result1 = p.pop();
    assert(result1.first == &quot;z&quot; &amp;&amp; result1.second == 8);
    auto result2 = p.pop();
    assert(result2.first == &quot;x&quot; &amp;&amp; result2.second == 15);
}
</code></pre>
    </div>
    <div class="algorithm-page">
        <div class="algorithm-header">
            <h2>Segment Tree</h2>
            <div class="algorithm-filename">segment_tree.cpp</div>
        </div>
        <pre><code>/*
Segment tree for efficient range queries and updates.

Supports range sum queries, point updates, and can be easily modified for other operations
like range minimum, maximum, or more complex functions. The tree uses 1-indexed array
representation with lazy propagation for range updates.

Time complexity: O(log n) for query and update operations, O(n) for construction.
Space complexity: O(n) for the tree structure.
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
#include &lt;cassert&gt;
#include &lt;numeric&gt;
#include &lt;string&gt;

template&lt;typename T&gt;
class SegmentTree {
private:
    int n;
    T zero;
    std::vector&lt;T&gt; tree;

    void build(const std::vector&lt;T&gt;&amp; arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
        } else {
            int mid = (start + end) / 2;
            build(arr, 2 * node, start, mid);
            build(arr, 2 * node + 1, mid + 1, end);
            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }
    }

    void update_helper(int node, int start, int end, int idx, T val) {
        if (start == end) {
            tree[node] = val;
        } else {
            int mid = (start + end) / 2;
            if (idx &lt;= mid) {
                update_helper(2 * node, start, mid, idx, val);
            } else {
                update_helper(2 * node + 1, mid + 1, end, idx, val);
            }
            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }
    }

    T query_helper(int node, int start, int end, int left, int right) {
        if (right &lt; start || left &gt; end) {
            return zero;
        }
        if (left &lt;= start &amp;&amp; end &lt;= right) {
            return tree[node];
        }
        int mid = (start + end) / 2;
        T left_sum = query_helper(2 * node, start, mid, left, right);
        T right_sum = query_helper(2 * node + 1, mid + 1, end, left, right);
        return left_sum + right_sum;
    }

public:
    SegmentTree(const std::vector&lt;T&gt;&amp; arr, T zero) : n(arr.size()), zero(zero) {
        tree.resize(4 * n, zero);
        if (!arr.empty()) {
            build(arr, 1, 0, n - 1);
        }
    }

    void update(int idx, T val) {
        if (idx &lt; 0 || idx &gt;= n) {
            throw std::out_of_range(&quot;Index &quot; + std::to_string(idx) + &quot; out of bounds for size &quot; + std::to_string(n));
        }
        update_helper(1, 0, n - 1, idx, val);
    }

    T query(int left, int right) {
        if (left &lt; 0 || right &gt;= n || left &gt; right) {
            throw std::out_of_range(&quot;Invalid range [&quot; + std::to_string(left) + &quot;, &quot; + std::to_string(right) +
                                   &quot;] for size &quot; + std::to_string(n));
        }
        return query_helper(1, 0, n - 1, left, right);
    }
};

void test_main() {
    SegmentTree&lt;int&gt; st({1, 3, 5, 7, 9}, 0);
    assert(st.query(1, 3) == 15);
    st.update(2, 10);
    assert(st.query(1, 3) == 20);
    assert(st.query(0, 4) == 30);
}
</code></pre>
    </div>
    <div class="algorithm-page">
        <div class="algorithm-header">
            <h2>Topological Sort</h2>
            <div class="algorithm-filename">topological_sort.cpp</div>
        </div>
        <pre><code>/*
Topological sorting for Directed Acyclic Graphs (DAGs).

Produces a linear ordering of vertices such that for every directed edge (u, v),
vertex u comes before v in the ordering. Uses both DFS-based and Kahn&#x27;s algorithm
(BFS-based) approaches for different use cases.

Time complexity: O(V + E) for both algorithms, where V is vertices and E is edges.
Space complexity: O(V + E) for the graph representation and auxiliary data structures.
*/

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;optional&gt;
#include &lt;stdexcept&gt;
#include &lt;cassert&gt;

template&lt;typename NodeT&gt;
class TopologicalSort {
private:
    std::map&lt;NodeT, std::vector&lt;NodeT&gt;&gt; graph;
    std::map&lt;NodeT, int&gt; in_degree;

    enum Color { WHITE, GRAY, BLACK };

    bool dfs_helper(NodeT node, std::map&lt;NodeT, Color&gt;&amp; color, std::vector&lt;NodeT&gt;&amp; result) {
        if (color[node] == GRAY) {  // Back edge (cycle)
            return false;
        }
        if (color[node] == BLACK) {  // Already processed
            return true;
        }

        color[node] = GRAY;
        for (const auto&amp; neighbor : graph[node]) {
            if (!dfs_helper(neighbor, color, result)) {
                return false;
            }
        }

        color[node] = BLACK;
        result.push_back(node);
        return true;
    }

public:
    void add_edge(NodeT u, NodeT v) {
        if (graph.find(u) == graph.end()) {
            graph[u] = {};
            in_degree[u] = 0;
        }
        if (in_degree.find(v) == in_degree.end()) {
            in_degree[v] = 0;
            graph[v] = {};
        }

        graph[u].push_back(v);
        in_degree[v]++;
    }

    std::optional&lt;std::vector&lt;NodeT&gt;&gt; kahn_sort() {
        /*
        Topological sort using Kahn&#x27;s algorithm (BFS-based).

        Returns the topological ordering, or nullopt if the graph has a cycle.
        */
        std::map&lt;NodeT, int&gt; in_deg = in_degree;
        std::queue&lt;NodeT&gt; q;

        for (const auto&amp; [node, deg] : in_deg) {
            if (deg == 0) {
                q.push(node);
            }
        }

        std::vector&lt;NodeT&gt; result;

        while (!q.empty()) {
            NodeT node = q.front();
            q.pop();
            result.push_back(node);

            for (const auto&amp; neighbor : graph[node]) {
                in_deg[neighbor]--;
                if (in_deg[neighbor] == 0) {
                    q.push(neighbor);
                }
            }
        }

        // Check if all nodes are processed (no cycle)
        if (result.size() != in_degree.size()) {
            return std::nullopt;
        }

        return result;
    }

    std::optional&lt;std::vector&lt;NodeT&gt;&gt; dfs_sort() {
        /*
        Topological sort using DFS.

        Returns the topological ordering, or nullopt if the graph has a cycle.
        */
        std::map&lt;NodeT, Color&gt; color;
        for (const auto&amp; [node, _] : in_degree) {
            color[node] = WHITE;
        }

        std::vector&lt;NodeT&gt; result;

        for (const auto&amp; [node, _] : in_degree) {
            if (color[node] == WHITE &amp;&amp; !dfs_helper(node, color, result)) {
                return std::nullopt;
            }
        }

        std::reverse(result.begin(), result.end());
        return result;
    }

    bool has_cycle() {
        return !kahn_sort().has_value();
    }

    std::map&lt;NodeT, int&gt; longest_path() {
        /*
        Find longest path from each node in the DAG.

        Returns a map from each node to its longest path length.
        */
        auto topo_order = kahn_sort();
        if (!topo_order.has_value()) {
            throw std::runtime_error(&quot;Graph contains a cycle&quot;);
        }

        std::map&lt;NodeT, int&gt; dist;
        for (const auto&amp; [node, _] : in_degree) {
            dist[node] = 0;
        }

        for (const auto&amp; node : topo_order.value()) {
            for (const auto&amp; neighbor : graph[node]) {
                dist[neighbor] = std::max(dist[neighbor], dist[node] + 1);
            }
        }

        return dist;
    }
};

void test_main() {
    TopologicalSort&lt;int&gt; ts;
    std::vector&lt;std::pair&lt;int, int&gt;&gt; edges = {{5, 2}, {5, 0}, {4, 0}, {4, 1}, {2, 3}, {3, 1}};
    for (const auto&amp; [u, v] : edges) {
        ts.add_edge(u, v);
    }

    auto kahn_result = ts.kahn_sort();
    auto dfs_result = ts.dfs_sort();

    assert(kahn_result.has_value());
    assert(dfs_result.has_value());
    assert(!ts.has_cycle());

    // Test with cycle
    TopologicalSort&lt;int&gt; ts_cycle;
    ts_cycle.add_edge(1, 2);
    ts_cycle.add_edge(2, 3);
    ts_cycle.add_edge(3, 1);
    assert(ts_cycle.has_cycle());
}
</code></pre>
    </div>
    <div class="algorithm-page">
        <div class="algorithm-header">
            <h2>Union Find</h2>
            <div class="algorithm-filename">union_find.cpp</div>
        </div>
        <pre><code>/*
Union-find (disjoint-set union, DSU) maintains a collection of disjoint sets under two operations:

* find(x): return the representative (root) of the set containing x.
* union(x, y): merge the sets containing x and y.

Time complexity: O(alpha(n)) per operation with path compression and union by rank,
where alpha is the inverse Ackermann function (effectively constant for practical purposes).
*/

#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;

class UnionFind {
public:
    UnionFind* parent;
    int rank;

    UnionFind() : parent(this), rank(0) {}

    virtual void merge(UnionFind* other) {
        // Override with desired functionality
    }

    UnionFind* find() {
        if (parent == this) {
            return this;
        }
        parent = parent-&gt;find();
        return parent;
    }

    UnionFind* union_with(UnionFind* other) {
        UnionFind* x = this-&gt;find();
        UnionFind* y = other-&gt;find();
        if (x == y) {
            return x;
        }
        if (x-&gt;rank &lt; y-&gt;rank) {
            x-&gt;parent = y;
            y-&gt;merge(x);
            return y;
        }
        if (x-&gt;rank &gt; y-&gt;rank) {
            y-&gt;parent = x;
            x-&gt;merge(y);
            return x;
        }
        x-&gt;parent = y;
        y-&gt;merge(x);
        y-&gt;rank++;
        return y;
    }
};

class Test : public UnionFind {
public:
    int size;

    Test() : UnionFind(), size(1) {}

    void merge(UnionFind* other) override {
        Test* other_test = static_cast&lt;Test*&gt;(other);
        this-&gt;size += other_test-&gt;size;
    }
};

void test_main() {
    Test* a = new Test();
    Test* b = new Test();
    Test* c = new Test();
    Test* d = static_cast&lt;Test*&gt;(a-&gt;union_with(b));
    Test* e = static_cast&lt;Test*&gt;(d-&gt;union_with(c));
    assert(static_cast&lt;Test*&gt;(e-&gt;find())-&gt;size == 3);
    assert(static_cast&lt;Test*&gt;(a-&gt;find())-&gt;size == 3);

    delete a;
    delete b;
    delete c;
}
</code></pre>
    </div>
</body>
</html>